I am trying to set up a contact listener in joltc.
But whenever any contacts happen, the application crashes.
I've debugged it with the visual studio debugger, and this is the callstack:

```
Salamander.exe!std::_Atomic_storage<unsigned __int64,8>::load(const std::memory_order _Order) Line 1062	C++
Salamander.exe!JPH::FixedSizeFreeList<JPH::JobSystem::Job>::ConstructObject<char const * &,JPH::Color &,JPH::JobSystemThreadPool *,std::function<void __cdecl(void)> const &,unsigned int &>(const char * & <inParameters_0>, JPH::Color & <inParameters_1>, JPH::JobSystemThreadPool * && <inParameters_2>, const std::function<void __cdecl(void)> & <inParameters_3>, unsigned int & <inParameters_4>) Line 59	C++
Salamander.exe!JPH::JobSystemThreadPool::CreateJob(const char * inJobName, JPH::Color inColor, const std::function<void __cdecl(void)> & inJobFunction, unsigned int inNumDependencies) Line 128	C++
Salamander.exe!ManagedContactListener::OnContactValidate(const JPH::Body & inBody1, const JPH::Body & inBody2, const JPH::Vec3 inBaseOffset, const JPH::CollideShapeResult & inCollisionResult) Line 6858	C++
Salamander.exe!JPH::ContactConstraintManager::ValidateContactPoint(const JPH::Body & inBody1, const JPH::Body & inBody2, const JPH::Vec3 inBaseOffset, const JPH::CollideShapeResult & inCollisionResult) Line 70	C++
Salamander.exe!`JPH::PhysicsSystem::ProcessBodyPair'::`23'::ReductionCollideShapeCollector::AddHit(const JPH::CollideShapeResult & inResult) Line 1079	C++
Salamander.exe!JPH::ConvexShape::sCollideConvexVsConvex(const JPH::Shape * inShape1, const JPH::Shape * inShape2, const JPH::Vec3 inScale1, const JPH::Vec3 inScale2, const JPH::Mat44 & inCenterOfMassTransform1, const JPH::Mat44 & inCenterOfMassTransform2, const JPH::SubShapeIDCreator & inSubShapeIDCreator1, const JPH::SubShapeIDCreator & inSubShapeIDCreator2, const JPH::CollideShapeSettings & inCollideShapeSettings, JPH::CollisionCollector<JPH::CollideShapeResult,JPH::CollisionCollectorTraitsCollideShape> & ioCollector, const JPH::ShapeFilter & inShapeFilter) Line 163	C++
Salamander.exe!JPH::CollisionDispatch::sCollideShapeVsShape(const JPH::Shape * inShape1, const JPH::Shape * inShape2, const JPH::Vec3 inScale1, const JPH::Vec3 inScale2, const JPH::Mat44 & inCenterOfMassTransform1, const JPH::Mat44 & inCenterOfMassTransform2, const JPH::SubShapeIDCreator & inSubShapeIDCreator1, const JPH::SubShapeIDCreator & inSubShapeIDCreator2, const JPH::CollideShapeSettings & inCollideShapeSettings, JPH::CollisionCollector<JPH::CollideShapeResult,JPH::CollisionCollectorTraitsCollideShape> & ioCollector, const JPH::ShapeFilter & inShapeFilter) Line 39	C++
Salamander.exe!JPH::PhysicsSystem::sDefaultSimCollideBodyVsBody(const JPH::Body & inBody1, const JPH::Body & inBody2, const JPH::Mat44 & inCenterOfMassTransform1, const JPH::Mat44 & inCenterOfMassTransform2, JPH::CollideShapeSettings & ioCollideShapeSettings, JPH::CollisionCollector<JPH::CollideShapeResult,JPH::CollisionCollectorTraitsCollideShape> & ioCollector, const JPH::ShapeFilter & inShapeFilter) Line 981	C++
[External Code]	
Salamander.exe!JPH::PhysicsSystem::ProcessBodyPair(JPH::ContactConstraintManager::ContactAllocator & ioContactAllocator, const JPH::BodyPair & inBodyPair) Line 1159	C++
Salamander.exe!JPH::PhysicsSystem::JobFindCollisions(JPH::PhysicsUpdateContext::Step * ioStep, int inJobIndex) Line 960	C++
```

The last function in the call stack that the application crashed on was the load function of the
atomic storage class in std. Visual Studio says that it's a read access violation and that _Mem
was 0x160 in this function:

```
    _NODISCARD _TVal load(
        const memory_order _Order = memory_order_seq_cst) const noexcept { // load with given memory order
        const auto _Mem = _STD _Atomic_address_as<long long>(_Storage);
        long long _As_bytes;
#if _STD_ATOMIC_USE_ARM64_LDAR_STLR == 1
        _ATOMIC_LOAD_ARM64(_As_bytes, 64, _Mem, static_cast<unsigned int>(_Order))
#else // ^^^ _STD_ATOMIC_USE_ARM64_LDAR_STLR == 1 / _STD_ATOMIC_USE_ARM64_LDAR_STLR != 1 vvv

#ifdef _M_ARM
        _As_bytes = __ldrexd(_Mem);
#else
        _As_bytes = __iso_volatile_load64(_Mem);
#endif

        _ATOMIC_POST_LOAD_BARRIER_AS_NEEDED(static_cast<unsigned int>(_Order))
#endif // ^^^ _STD_ATOMIC_USE_ARM64_LDAR_STLR != 1 ^^^
        return reinterpret_cast<_TVal&>(_As_bytes);
    }
```

The last jolt function was:

```
uint32 FixedSizeFreeList<Object>::ConstructObject(Parameters &&... inParameters)
```

Whose next statement to be executed was this:

```
uint64 first_free_object_and_tag = mFirstFreeObjectAndTag.load(memory_order_acquire);
```

This was the 'locals' section of this function.

```
this	                    0x00000000000000c0 {mPageSize=??? mPageShift=??? mObjectMask=??? ...} JPH::FixedSizeFreeList<JPH::JobSystem::Job> *
<inParameters_0>            0x0000024027e1ab00 ""	const char * &
<inParameters_1>            {mU32=0x837e7ec8 r=0xc8 'Ãˆ' g=0x7e '~' ...}	JPH::Color &
<inParameters_2>            0x0000000000000000 <NULL>	JPH::JobSystemThreadPool * &&
<inParameters_3>            empty	const std::function<void __cdecl(void)> &
<inParameters_4>            0x00000000	unsigned int &
first_free	            0xcccccccc	unsigned int
first_free_object_and_tag   0xcccccccccccccccc	unsigned __int64

